<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init all necessary variables

back_instance = instance_create(x, y, obj_tetris_back);
back_instance.controller = id;
back_scroll_spd = 0.2;

// Controlls
button_left_1  = vk_left;
button_left_2  = ord('A');
button_right_1 = vk_right;
button_right_2 = ord('D');
button_down_1  = vk_down;
button_down_2  = ord('S');
button_up_1    = vk_up;
button_up_2    = ord('W');

button_turn_left_1  = ord('Y');
button_turn_left_2  = ord('Q');
button_turn_right_1 = ord('X');
button_turn_right_2 = ord('E');

button_pause_1 = vk_enter;
button_pause_2 = vk_space;

pressed_right = false;
pressed_left  = false;
pressed_up    = false;
pressed_down  = false;
pressed_turn_left  = false;
pressed_turn_right = false;
pressed_pause = false;

key_blocker = 0;
key_blocker_max = 100000;

// Settings
stone_size = 32;            // Stone part size in pixels
stone_grid_size = 4;        // Number of parts a stone can have per row and column
fall_time  = 500000;
fall_counter = fall_time;
collision = false;

// Game area
border_left   = 96;
border_right  = room_width - 160;
border_top    = -64;
border_bottom = room_height;

game_area_w = border_right - border_left; // Width of the game area in pixels
game_area_h = border_bottom - border_top; // Height of the game area in pixels

fields_x = game_area_w div stone_size;    // Number of horizontal fields
fields_y = game_area_h div stone_size;    // Number of vertical fields

// Spawn new stones at the top center
new_stones_x = border_left + (game_area_w / 2) - (stone_grid_size / 2) * stone_size; // X coordinate for new stones
new_stones_y = border_top;                                                           // Y coordinate for new stones

stone_preview_x = border_right + (stone_size / 2); // X coordinate where the stone preview should be drawn
stone_preview_y = border_top   + (stone_size * 3); // Y coordinate where the stone preview should be drawn                 

// Game states
pause = false;
win = false;       // For now there is no possibility to "win" that game
game_over = false;
score = 0;
score_fade = 0;

// Init game area fields. Every field will hold a reference to the stone that lies in this field
for (var yy = fields_y - 1; yy &gt;= 0; yy--) {
    for (var xx = fields_x - 1; xx &gt;= 0; xx--) {
        game_area[yy, xx] = -1;
    }
}

next_stone = noone;     // Holds the stone that will come next
current_stone = noone;  // Holds the stone falling at this moment

falling_stones = ds_list_create();  // Holds references to all stones that have to fall after a clearing

// Game instances
event_user(4);  // Create first tetris stone
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Clear memory</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(falling_stones); // Holds references to all stones that have to fall after a clearing
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// === Controlling ===

if (keyboard_check_pressed(button_left_1) || keyboard_check_pressed(button_left_2)) {
    pressed_right = false;
    pressed_left  = true;
    pressed_up    = false;
    pressed_down  = false;
    key_blocker = 0;
}
if (keyboard_check_pressed(button_right_1) || keyboard_check_pressed(button_right_2)) {
    pressed_right = true;
    pressed_left  = false;
    pressed_up    = false;
    pressed_down  = false;
    key_blocker = 0;
}
if (keyboard_check_pressed(button_up_1) || keyboard_check_pressed(button_up_2)) {
    pressed_right = false;
    pressed_left  = false;
    pressed_up    = true;
    pressed_down  = false;
    key_blocker = 0;
}
if (keyboard_check_pressed(button_down_1) || keyboard_check_pressed(button_down_2)) {
    pressed_right = false;
    pressed_left  = false;
    pressed_up    = false;
    pressed_down  = true;
    key_blocker = 0;
}
if (keyboard_check_pressed(button_pause_1) || keyboard_check_pressed(button_pause_2)) {
    pressed_pause = true;
}

if (keyboard_check_pressed(button_turn_left_1) || keyboard_check_pressed(button_turn_left_2)) {
    pressed_turn_left = true;
}
else {
    pressed_turn_left = false;
}
if (keyboard_check_pressed(button_turn_right_1) || keyboard_check_pressed(button_turn_right_2)) {
    pressed_turn_right = true;
}
else {
    pressed_turn_right = false;
}


if (!keyboard_check(button_left_1) &amp;&amp; !keyboard_check(button_left_2)) {
    pressed_left  = false;
}
if (!keyboard_check(button_right_1) &amp;&amp; !keyboard_check(button_right_2)) {
    pressed_right = false;
}
if (!keyboard_check(button_up_1) &amp;&amp; !keyboard_check(button_up_2)) {
    pressed_up    = false;
}
if (!keyboard_check(button_down_1) &amp;&amp; !keyboard_check(button_down_2)) {
    pressed_down  = false;
}
if (!keyboard_check(button_pause_1) &amp;&amp; !keyboard_check(button_pause_2)) {
    pressed_pause  = false;
}

if (!pause &amp;&amp; !game_over) {
    if (pressed_pause) {
        pause = true;
        keyboard_clear(button_pause_1); // Don't react to these keys again in the same frame
        keyboard_clear(button_pause_2);
        pressed_pause = false;
    }
}

if (!pause) {
    if (!game_over) {
        if (current_stone != noone) {
            collision = false;
            // Moving the stone
            if (key_blocker &lt;= 0) {
                if (pressed_left) {
                    if (current_stone.x + current_stone.border_left * stone_size &gt; border_left) {
                        with (current_stone) {
                            x -= other.stone_size;
                            if (tetris_check_collision()) {
                                x += other.stone_size;
                            }
                        }
                    }
                    key_blocker = key_blocker_max;
                }
                if (pressed_right) {
                    if (current_stone.x + current_stone.border_right * stone_size &lt; border_right) {
                        with (current_stone) {
                            x += other.stone_size;
                            if (tetris_check_collision()) {
                                x -= other.stone_size;
                            }
                        }
                    }
                    key_blocker = key_blocker_max;
                }
                if (pressed_down) {
                    if (current_stone.y + current_stone.border_bottom * stone_size &lt; border_bottom) {
                        with (current_stone) {
                            y += other.stone_size;
                            if (tetris_check_collision()) {
                                y -= other.stone_size;
                                other.collision = true;
                            }
                        }
                    }
                    key_blocker = key_blocker_max;
                }
            }
            else {
                key_blocker -= delta_time;
            }
            
            if (!collision) {
                if (pressed_turn_left) {
                    with (current_stone) {
                        tetris_stone_turn_left();
                    }
                }
                if (pressed_turn_right) {
                    with (current_stone) {
                        tetris_stone_turn_right();
                    }
                }
                
                // Automatic fall down
                if (fall_counter &lt;= 0) {
                    with (current_stone) {
                        y += other.stone_size;
                        other.fall_counter = other.fall_time;
                        if (tetris_check_collision()) {
                            y -= other.stone_size;
                            other.collision = true;
                        }
                        else if (y + border_bottom * other.stone_size &gt; other.border_bottom) {
                            y -= other.stone_size;
                            other.collision = true;
                        }
                    }
                }
                fall_counter -= delta_time;
                
                // Touch ground / Collision
                /*if (current_stone.y + 4 * stone_size &gt;= room_height) {
                    collision = true;
                }*/
            }
            
            if (collision) {
                // Stop moving the stone, save its parts in the game area array
                event_user(5);
            }
            
        }
        else if (!ds_list_empty(falling_stones)) {
            if (fall_counter &lt;= 0) {
                var stones_moved, moving_circles = 0;
                do { // Repeat this until no stone is moveable anymore
                    stones_moved = 0;
                    for (var stone_index = 0; stone_index &lt; ds_list_size(falling_stones); stone_index++) {
                        var stone_instance = ds_list_find_value(falling_stones, stone_index);
                        with (stone_instance) {
                            if (!moved) {   // Only fall one field per step
                                y += other.stone_size;
                                if (tetris_check_collision()) {
                                    y -= other.stone_size;
                                }
                                else if (y + border_bottom * other.stone_size &gt; other.border_bottom) {
                                    y -= other.stone_size;
                                }
                                else {
                                    y -= other.stone_size;
                                    with (other) {
                                        tetris_unlink_stone_to_game_area(stone_instance);
                                    }
                                    y += other.stone_size;
                                    with (other) {
                                        tetris_link_stone_to_game_area(stone_instance);
                                    }
                                    moved = true;   // Remember this stone has moved in this step
                                    stones_moved++;
                                }
                            }
                        }
                    }
                    moving_circles++;
                } until (stones_moved == 0);
                
                // Mark all stones as "not yet moved" for the next falling step
                for (var stone_index = 0; stone_index &lt; ds_list_size(falling_stones); stone_index++) {
                    var stone_instance = ds_list_find_value(falling_stones, stone_index);
                    stone_instance.moved = false;
                }
                if (moving_circles == 1) { // No stone could be moved - falling is finished
                    ds_list_clear(falling_stones);
                }
                else { // Set counter for next falling
                    fall_counter = fall_time;
                }
            }
            else {
                fall_counter -= delta_time;
            }
        }
        else {
            // Next stone please
            event_user(4);  // Start next one
        }
    }
    else { // Game is over
        current_stone = noone;
        next_stone = noone;
        
        if (pressed_pause) {
            // Remove all stones
            with (obj_tetris_stone) {
                instance_destroy();
            }
            // Clear game area
            for (var yy = 0; yy &lt; fields_y; yy++) {
                for (var xx = 0; xx &lt; fields_x; xx++) {
                    game_area[yy, xx] = -1;
                }
            }
            // Start new game
            game_over = false;
            event_user(4);
            
            keyboard_clear(button_pause_1); // Don't react to these keys again in the same frame
            keyboard_clear(button_pause_2);
            pressed_pause = false;
        }
        
    }
}
else { // While game is paused
    if (pressed_pause) {
        pause = false;
        keyboard_clear(button_pause_1); // Don't react to these keys again in the same frame
        keyboard_clear(button_pause_2);
        pressed_pause = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set scaling
image_xscale = sprite_get_width(sprite_index)  / controller.stone_size;
image_yscale = sprite_get_height(sprite_index) / controller.stone_size;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Stop stone &amp; clear lines</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// If there already is a stone that now has to stop moving, save its parts in the game area array
if (current_stone != noone) {
    
    // Init game area fields. Every field will hold a reference to the stone that lies in this field
    tetris_link_stone_to_game_area(current_stone);
    
    score += global.SCORE_STONE_PLACED;
    
    var xx = (current_stone.x - border_left) div stone_size;
    var yy = (current_stone.y - border_top)  div stone_size;
    
    // Check for lines that can be cleared
    tetris_check_for_clearing(yy + current_stone.border_top, yy + current_stone.border_bottom);
    
    current_stone = noone;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Next stone</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Create new stone, if there is now current one yet
if (current_stone == noone) {
    
    // Create new stone at the top
    if (next_stone == noone) {
        current_stone = instance_create(new_stones_x, new_stones_y, obj_tetris_stone);
        current_stone.controller = id;
        with (current_stone) {
            event_user(6);  // Set sprite scaling
        }
    }
    else {
        current_stone = next_stone;
        current_stone.x = new_stones_x;
        current_stone.y = new_stones_y;
    }
    
    next_stone = instance_create(stone_preview_x, stone_preview_y, obj_tetris_stone);
    next_stone.controller = id;
    with (next_stone) {
        event_user(6);  // Set sprite scaling
    }
    
    with (current_stone) {
        // Calculate the indices of the fields in the parts grid (array)
        tetris_calculate_stone_borders();
        if (tetris_check_collision()) {
            // No free space left at spawn point - game over
            other.game_over = true;
            other.win = false;
        }
    }
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw boarders, debug infos and text

// Draw borders
draw_set_color(c_black);
if (border_left &gt; 0) {
    draw_line(border_left, border_top, border_left, border_bottom);
}
if (border_right &lt; room_width) {
    draw_line(border_right, border_top, border_right, border_bottom);
}
if (border_bottom &lt; room_height) {
    draw_line(border_left, border_bottom, border_right, border_bottom);
}


if (global.debug) {
    // Draw game area numbers for debugging
    draw_set_color(c_gray);
    draw_set_alpha(0.5);
    draw_set_valign(fa_middle);
    for (var field_y = 0; field_y &lt; fields_y; field_y++) {
        draw_text(border_left + 4, border_top + (0.5 + field_y) * stone_size, string(field_y));
    }
    draw_set_valign(fa_top);
    draw_set_halign(fa_center);
    var h = string_height("I");
    for (var field_x = 1; field_x &lt; fields_x; field_x++) {
        draw_text(border_left + (0.5 + field_x) * stone_size, border_bottom - h - 4, string(field_x));
    }
    draw_set_halign(fa_left);
    draw_set_alpha(1);

    // Draw game area array for debugging
    var mini_x = 16;
    var mini_y = 16;
    var mini_size = 4;
    var xxx, yyy;
    
    for (var yy = 0; yy &lt; fields_y; yy++) {
        for (var xx = 0; xx &lt; fields_x; xx++) {
            if (game_area[yy, xx] &gt;= 0) {
                xxx = mini_x + xx * mini_size;
                yyy = mini_y + yy * mini_size;
                draw_set_color(game_area[yy, xx].image_blend);
                draw_rectangle(xxx, yyy, xxx + mini_size, yyy + mini_size, false);
            }
        }
    }
    draw_set_color(c_black);
    draw_rectangle(mini_x, mini_y, mini_x + mini_size * fields_x, mini_y + mini_size * fields_y, true);
}

// Next stone background
draw_set_alpha(0.3);
var ns_x1 = stone_preview_x - stone_size / 4, ns_y1 = stone_preview_y - stone_size / 4;
var ns_x2 = ns_x1 + (stone_grid_size + 0.5) * stone_size, ns_y2 = ns_y1 + (stone_grid_size + 0.5) * stone_size;
draw_roundrect_colour(ns_x1, ns_y1, ns_x2, ns_y2, c_gray, c_ltgray, false);
draw_roundrect(ns_x1, ns_y1, ns_x2, ns_y2, true);
draw_set_alpha(1);

// Score
if (score_fade &lt; score) {
    var dif = (score - score_fade) / 8;
    score_fade = floor(min(score_fade + max(dif, 10), score));
}
var score_draw = "Score#" + string_fill_left(string(score_fade), "0", 6);
var sc_x = border_right + stone_size / 2;
var sc_y = border_top + stone_size * 8;
draw_text(sc_x, sc_y, score_draw);
draw_text_colour(sc_x + 1, sc_y + 1, score_draw, c_blue, c_blue, c_navy, c_navy, 1);

// Pause
if (pause) {
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    
    draw_set_color(c_black);
    draw_text(room_width / 2, room_height / 2, "PAUSE");
    
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
}

// Game Over
if (game_over) {
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    
    draw_set_color(c_black);
    draw_text(room_width / 2, room_height / 2, "GAME OVER");
    
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="27">
      <action>
        <libid>1</libid>
        <id>332</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_end_game</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="9" enumb="8">
      <action>
        <libid>1</libid>
        <id>223</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_current_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
